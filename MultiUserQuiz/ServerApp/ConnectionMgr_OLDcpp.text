#include "ConnectionMgr_OLD.hpp"
#include "../QuizMgr.h"

std::map<connection_hdl, std::string, std::owner_less<connection_hdl>> hdl_to_username;
std::unordered_map<std::string, std::shared_ptr<User>> username_to_user;
std::shared_mutex session_mutex;

std::shared_ptr<asio::ssl::context> on_tls_init (websocketpp::connection_hdl hdl)
{
    auto ctx = std::make_shared<asio::ssl::context> (asio::ssl::context::tlsv12);
    try {
        ctx->set_options (
            asio::ssl::context::default_workarounds |
            asio::ssl::context::no_sslv2 |
            asio::ssl::context::single_dh_use);

        ctx->use_certificate_chain_file ("server.crt");
        ctx->use_private_key_file ("server.key", asio::ssl::context::pem);

        std::cout << "TLS init succeeded." << std::endl;
    } catch (std::exception & e) {
        std::cout << "TLS init failed: " << e.what () << std::endl;
    }
    return ctx;
}

bool check_if_time_has_elapsed (std::shared_ptr<User> pUser, eQuizMode pMode)
{
    if (pMode == BULLET_TIMER_MODE) {
        // In bullet timer mode, we don't check time elapsed, as it is not relevant.
        return false;
    } else if (pMode == STRICT_TIME_BOUND_MODE) {

        long long current_time = QuizHelper::get_current_time_in_ms ();
        long long end_time = pUser->GetEndTimeInMs ();

        if (current_time >= end_time) {
            // Time has elapsed
            return true;
        }
    } else if (pMode == TIME_BOUND_MODE) {

        // In time bound mode, we check if the total time limit has been reached.
        long long elapsed_time = pUser->GetElapsedTime ();
        long long total_time_limit = pUser->GetTotalTimeLimit ();

        if (elapsed_time >= total_time_limit) {
            // Time has elapsed
            return true;
        }
    }
    return false;
}

// TODO: timer based check till which point the user will be allowed to login/relogin
json handle_login_request (connection_hdl hdl, string password, string username)
{
        json response;

    if (password != "1234") {
        return {{"type", "LOGIN_FAIL"}, {"reason", "Invalid credentials"}};
    }

    {
        std::unique_lock lock (session_mutex);

        // Check if already logged in from another connection - some fake user trying to connect or trying to make 2 connections for same user.
        for (const auto & [existing_hdl, existing_user] : hdl_to_username) {
            if (existing_user == username) {
                return {{"type", "LOGIN_FAIL"}, {"reason", "User already logged in"}};
            }
        }

        // Allow re-login only if quiz already started (user object exists)
        if (username_to_user.find (username) != username_to_user.end ()) {
            hdl_to_username[hdl] = username;
            // "Reconnected" indicates that the client should call continue quiz instead of start quiz.
            return {{"type", "LOGIN_OK"}, {"welcome", username}, {"note", "Reconnected"}};
        }

        // Fresh login only if user hasn't already started quiz
        hdl_to_username[hdl] = username;
    }

    return {{"type", "LOGIN_OK"}, {"welcome", username}};
}

void StrictQuizTimedOut ()
{
    std::cerr << "[TIMER] Time expired" << std::endl;
    // Don't stop the server - as login should be allowed.
    // But only know checking the result should be allowed as the quiz have already ended.

}

json handle_start_quiz (connection_hdl hdl)
{
        std::string     uname;
        unsigned int    ques_count      = QuestionBank::GetInstance ().TotalQuestionCount ();
        QuizConfig &    cfg             = QuizConfig::GetInstance ();
        eQuizMode       quiz_mode       = cfg.GetQuizMode ();
        bool            is_bullet_mode  = (quiz_mode == BULLET_TIMER_MODE);
        long long       time_allowed_in_ms    = cfg.GetTimeAllowedBasedOnQuizMode () * 1000;
        long long       end_time_in_ms  = 0;

    {
        std::shared_lock lock (session_mutex);
        auto it = hdl_to_username.find (hdl);
        if (it == hdl_to_username.end ()) {
            return {{"type", "ERROR"}, {"message", "Please login first"}};
        }
        uname = it->second;

        if (username_to_user.find (uname) != username_to_user.end ()) {
            // this will also handle re-connection cases - after reconnection start quiz will not be allowed.
            // on reconnection client should call continue quiz command.
            return {{"type", "ERROR"}, {"message", "Quiz already started"}};
        }
    }

    {
        std::unique_lock lock (session_mutex);
        username_to_user[uname] = std::make_shared<User> (uname);

        if (!is_bullet_mode) {

            username_to_user[uname]->SetTotalTimeLimit (time_allowed_in_ms);

            if (quiz_mode == STRICT_TIME_BOUND_MODE) {

                // case strict time bound mode - so start time and end time will be fixed.
                username_to_user[uname]->SetStartTimeInMs (QuizHelper::get_current_time_in_ms ());
                username_to_user[uname]->SetEndTimeInMs (username_to_user[uname]->GetStartTimeInMs () + (time_allowed_in_ms));
                end_time_in_ms = username_to_user[uname]->GetEndTimeInMs ();
            }
        } else {
            // this is for tracking and for fastest finger first result - tracking time in bullet mode.
            username_to_user[uname]->SetTotalTimeLimit (time_allowed_in_ms * ques_count);
        }

        time_allowed_in_ms = username_to_user[uname]->GetTotalTimeLimit ();
    }

    // if strict mode, then the timer should be started by server
    if (quiz_mode == STRICT_TIME_BOUND_MODE) {

        std::unique_ptr<QuestionTimer>  quizTimer;

        quizTimer = std::make_unique<QuestionTimer> (
            time_allowed_in_ms,
            std::bind (StrictQuizTimedOut)
        );
    }

    return {
        {"type",                    "QUIZ_STARTED"}, 
        {"total_questions",         ques_count},
        {"quiz_mode",               quiz_mode},
        {"is_multioption_allowed",  cfg.IsMultiOptionSelect ()},
        {"is_kbc_mode",             cfg.IsKBCMode ()},
        {"total_time",              time_allowed_in_ms},
        {"end_time",                end_time_in_ms}     // used in strict time mode to show remaining time at client
    };
}

json handle_continue_quiz (connection_hdl hdl)
{

    unsigned int ques_count = QuestionBank::GetInstance ().TotalQuestionCount ();
    QuizConfig & cfg = QuizConfig::GetInstance ();
    eQuizMode    quiz_mode = cfg.GetQuizMode ();
    bool is_bullet_mode = (quiz_mode == BULLET_TIMER_MODE);

    std::shared_ptr<User> user;
    {
        std::shared_lock lock (session_mutex);
        auto it = hdl_to_username.find (hdl);
        if (it == hdl_to_username.end ()) {
            return {{"type", "ERROR"}, {"message", "Please login first"}};
        }

        auto uit = username_to_user.find (it->second);
        if (uit == username_to_user.end ()) {

            return {{"type", "ERROR"}, {"message", "Quiz was not started"}};
        }
        user = uit->second;

    }

    if (quiz_mode == TIME_BOUND_MODE) {
        // in time bound mode, if reconnection happens that means the elapsed time should be updated, which is done using last activity time.
        // and after updating elapsed time on disconnection, the last activity time should be resetted.
        if (user->GetlastActivityTimeInMs () != 0) {
            std::cerr<<"Something went wrong";
            _exit (-1);
            return {};
        }
    }

    // Check if it is allowed or not and update the time elapsed.
    if (check_if_time_has_elapsed (user, quiz_mode)) {

        std::cerr << "Time has elapsed not allowed to fetch question" << std::endl;
        return {};
    }

    // fetch unattempted questions.
    const std::vector<unsigned int> unattempted = user->GetUnattemptedQuestionIds ();

    if (unattempted.empty ()) {
        // all attempted - just end quiz.
        return  {
            {"type", "QUIZ_ENDED"}
        };
    }

    return {

        {"type",                    "QUIZ_RESTARTED"},
        {"total_questions",         ques_count},
        {"quiz_mode",               quiz_mode},
        {"is_multioption_allowed",  cfg.IsMultiOptionSelect ()},
        {"is_kbc_mode",             cfg.IsKBCMode ()},
        {"total_time",              user->GetTotalTimeLimit ()},
        {"updated_elapsed_time",    user->GetElapsedTime ()},
        {"end_time",                user->GetEndTimeInMs ()},
        {"question_ids",            unattempted}
    };
}


// returning the user outside the mutex lock is fine bcz we are sure that same username cannot exist from 2 handles.
// coz the client is synchronous it will wait for the response of this request before proceeding to any other request.
std::shared_ptr<User> check_and_return_user (connection_hdl hdl, json & pOutResp)
{
    std::shared_lock lock (session_mutex);
    auto it = hdl_to_username.find (hdl);
    if (it == hdl_to_username.end ()) {
        pOutResp = {{"type", "ERROR"}, {"message", "Please login first"}};
        return nullptr;
    }

    auto uit = username_to_user.find (it->second);
    if (uit == username_to_user.end ()) {

        pOutResp = {{"type", "ERROR"}, {"message", "Start the quiz first"}};
        return nullptr;
    }

    return uit->second;
}

void calculate_elapsed_time_on_disconnection (std::shared_ptr<User> pUser)
{
    QuizConfig & cfg = QuizConfig::GetInstance ();
    eQuizMode    quiz_mode = cfg.GetQuizMode ();
    long long   last_activity_time = pUser->GetlastActivityTimeInMs ();

    if (last_activity_time == 0) {
        // no question were checked - quiz was just started.
        return;
    }

    if (quiz_mode == BULLET_TIMER_MODE) {
        // In bullet timer mode, we don't calculate elapsed time on disconnection.
        return;
    } else if (quiz_mode == STRICT_TIME_BOUND_MODE) {
        // In strict time bound mode, we rely on actual time. and 
        // fastest finger will be calculated at end of quiz.
        return;
    } else if (quiz_mode == TIME_BOUND_MODE) {
        // In time bound mode, we calculate elapsed time based on the last activity time.
        long long current_time = QuizHelper::get_current_time_in_ms ();
        long long elapsed_time = current_time - last_activity_time;
        pUser->AddToElapsedTimeInQuiz (elapsed_time);
    }
    // reset the last activity time to 0, so that next time when user comes back, 
    // it will be treated as a new session.
    pUser->ResetLastActivityTimeInMs ();
    return;
}

string perform_logout (connection_hdl hdl) 
{
    std::string uname;
    {
        std::unique_lock lock (session_mutex);
        auto it = hdl_to_username.find (hdl);
        if (it != hdl_to_username.end ()) {

            uname = it->second;
            auto uit = username_to_user.find (uname);

            if (uit != username_to_user.end ()) {
                // quiz was started
                calculate_elapsed_time_on_disconnection (uit->second);
            }
            hdl_to_username.erase (it);
        }
    }
    return uname;
}

json handle_fetch_unattempted_ques (connection_hdl hdl)
{
    json            response;

    std::shared_ptr<User> user = check_and_return_user (hdl, response);

    if (user == nullptr) {
        return response;
    }

    // check if the test time has elapsed
    if (check_if_time_has_elapsed (user, QuizConfig::GetInstance ().GetQuizMode ())) {

        std::cerr << "Time has elapsed not allowed to fetch question" << std::endl;
        return response;
    }

    // Fetch unattempted questions for the user.
    const std::vector<unsigned int> unattempted = user->GetUnattemptedQuestionIds ();

    if (unattempted.empty ()) {
        // all attempted - just end quiz.
        return  {
            {"type", "QUIZ_ENDED"}
        };
    }

    response = {
        {"type", "UNATTEMPTED_QUESTIONS"},
        {"question_ids", unattempted}
    };

    return response;
}

long long calculate_question_timer (std::shared_ptr<User> pUser)
{
    QuizConfig & cfg = QuizConfig::GetInstance ();
    eQuizMode    quiz_mode = cfg.GetQuizMode ();

    if (quiz_mode == BULLET_TIMER_MODE) {

        // In bullet timer mode client should run the timer for each question based on the provided time in seconds.
        return cfg.GetTimeAllowedBasedOnQuizMode () * 1000;

    } else if (quiz_mode == TIME_BOUND_MODE) {

        // for time bound mode, we calculate the remaining time based on the total time limit and elapsed time.
        return (pUser->GetTotalTimeLimit () - pUser->GetElapsedTime ());
    } else {

        // for strict time bound mode
        return (pUser->GetEndTimeInMs () - QuizHelper::get_current_time_in_ms ()); 
    }
}

json process_request (connection_hdl hdl, json & req)
{
        json            response;
        std::string     type = req["type"];
        QuestionBank &  qb = QuestionBank::GetInstance ();

    if (type == "LOGIN") {

        const std::string username = req.value ("username", "");
        const std::string password = req.value ("password", "");

        return  handle_login_request (hdl, password, username);
    }

    else if (type == "START_QUIZ") {

        return handle_start_quiz (hdl);
    }
    else if (type == "CONTINUE_QUIZ") {

        // should be called after reconnection
        return handle_continue_quiz (hdl);
    }
    else if (type == "END_QUIZ") {

        // show result. this will be called in case of abort.
        std::shared_ptr<User> user = check_and_return_user (hdl, response);

        if (user == nullptr) {
            return response;
        }

        // TODO show result

    }
    else if (type == "FETCH_QUESTION") {

        std::shared_ptr<User> user = check_and_return_user (hdl, response);

        if (user == nullptr) {
            return response;
        }

        unsigned int qid = req.value ("question_id", 0);
        if (qid <= 0 || qid > qb.TotalQuestionCount ()) {

            return {{"type", "ERROR"}, {"message", "Invalid question ID"}};
        }

        // Check if it is allowed or not and update the time elapsed.
        if (check_if_time_has_elapsed (user, QuizConfig::GetInstance ().GetQuizMode ())) {

            std::cerr << "Time has elapsed not allowed to fetch question" << std::endl;
            return response;
        }

        // test time not elapsed - update the last activity time.
        user->SetLastActivityTimeInMs ();

        std::shared_ptr<const Question> q = qb.GetQuestionById (qid);

        response = {
            {"type",    "QUESTION"},
            {"id",      q->GetQuestionID ()},
            {"text",    q->GetQuestionText ()},
            {"options", q->GetQuestionOptions ()},
            {"total_time", user->GetTotalTimeLimit ()},
            {"updated_elapsed_time", user->GetElapsedTime ()},
            {"question_timer", calculate_question_timer (user)},
        };
    }
    else if (type == "FETCH_UNATTEMPTED") {

        return handle_fetch_unattempted_ques (hdl);

    }
    else if (type == "SUBMIT_ANSWER") {

        std::shared_ptr<User> user = check_and_return_user (hdl, response);

        if (user == nullptr) {
            return response;
        }

        // Check if it is allowed or not and update the time elapsed.
        if (check_if_time_has_elapsed (user, QuizConfig::GetInstance ().GetQuizMode ())) {

            std::cerr << "Time has elapsed not allowed to fetch question" << std::endl;
            return response;
        }
        // test time not elapsed - update the last activity time.
        user->SetLastActivityTimeInMs ();

        unsigned int qid = req.value ("question_id", 0);
        if (qid <= 0 || qid > qb.TotalQuestionCount ()) {

            return {{"type", "ERROR"}, {"message", "Invalid question ID"}};
        }

        Answer ans (qid);
        for (int op : req.value ("selected_options", std::vector<int>{})) {

            ans.SetSelectedOp (op);
        }

        long long time_to_attempt_in_ms = req.value ("time_to_attempt_in_ms", 0);
        user->AddToElapsedTimeInQuiz (time_to_attempt_in_ms);

        // TODO: status and score should be sent optionally based on KBC mode
        eQuesAttemptStatus status = user->SetAndValidateUserAnswer (ans);
        double score = user->GetUserCurrentScore ();

        response = {
            {"type", "ANSWER_SUBMITTED"},
            {"question_id", qid},
            {"status",  static_cast<int>(status)},
            {"score", score},
            {"total_time", user->GetTotalTimeLimit ()},
            {"updated_elapsed_time", user->GetElapsedTime ()},
        };

    }
    else if (type == "LOGOUT") {

        string uname = perform_logout (hdl);
        response = {{"type", "LOGOUT_OK"}, {"Bye", uname}};

    }
    else {
        // Unknown command
        response = {{"type", "ERROR"}, {"message", "Unknown command"}};
    }

    return response;
}

void on_message (server * s, connection_hdl hdl, server::message_ptr msg)
{
    try {

#ifdef DEBUG
        server::connection_ptr con = s->get_con_from_hdl (hdl);
        std::string client_info = con->get_remote_endpoint ();
        std::cout << "[MESSAGE] From " << client_info << ": " << msg->get_payload () << std::endl;
#endif

        json req = json::parse (msg->get_payload ());
        json response = process_request (hdl, req);

        s->send (hdl, response.dump (), websocketpp::frame::opcode::text);

    } catch (const std::exception & e) {

        std::cerr << "Exception: " << e.what () << std::endl;
    }
}

void on_open (server * s, connection_hdl hdl)
{
    auto con = s->get_con_from_hdl (hdl);
    std::string remote = con->get_remote_endpoint ();
    std::cout << "[CONNECTED] " << remote << std::endl;
}

void on_close (server * s, connection_hdl hdl)
{
    perform_logout (hdl);
}

void ConnectionMgr::StartServer ()
{
    server ws_server;

    try {

        ws_server.set_access_channels (websocketpp::log::alevel::none);
        ws_server.init_asio ();
        ws_server.set_tls_init_handler (bind (&on_tls_init, _1));
        ws_server.set_message_handler (bind (&on_message, &ws_server, _1, _2));
        ws_server.listen (9002);
        ws_server.start_accept ();

        // --- THREAD POOL START ---
        const int num_threads = std::thread::hardware_concurrency (); // or a fixed number

        std::vector<std::thread> threads;

        for (int i = 0; i < num_threads; ++i) {

            threads.emplace_back ([&ws_server] () {
                ws_server.run (); // each thread runs the IO loop
            });
        }

        // Join threads
        for (auto & t : threads) {
            t.join ();
        }

        // --- THREAD POOL END ---

    } catch (const std::exception & e) {
        std::cerr << "Error: " << e.what () << std::endl;
    }
}